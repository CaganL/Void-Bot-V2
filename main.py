import os
import telebot
import requests
import random
import json
import numpy as np
import textwrap
from PIL import Image, ImageDraw, ImageFont
from moviepy.editor import (
    VideoFileClip, AudioFileClip, ImageClip, CompositeVideoClip,
    concatenate_videoclips
)
import asyncio
import edge_tts

# --- AYARLAR ---
TELEGRAM_TOKEN = os.environ.get("TELEGRAM_TOKEN")
PEXELS_API_KEY = os.environ.get("PEXELS_API_KEY")
GEMINI_API_KEY = os.environ.get("GEMINI_API_KEY")

bot = telebot.TeleBot(TELEGRAM_TOKEN)

# YouTube Shorts iÃ§in Ã§Ã¶zÃ¼nÃ¼rlÃ¼k
W, H = 1080, 1920
FPS = 30

# --- FONT ---
def get_font():
    font_path = "Oswald-Bold.ttf"
    if not os.path.exists(font_path):
        url = "https://github.com/google/fonts/raw/main/ofl/oswald/Oswald-Bold.ttf"
        r = requests.get(url, timeout=10)
        if r.status_code == 200:
            with open(font_path, "wb") as f:
                f.write(r.content)
    return font_path

# --- TTS (edge-tts async) ---
async def generate_tts(text, out="voice.mp3", voice="en-US-GuyNeural"):
    communicate = edge_tts.Communicate(text, voice)
    try:
        await communicate.save(out)
    except Exception as e:
        print(f"TTS HatasÄ±: {e}")
        # Hata durumunda boÅŸ dosya yerine sessiz bir dosya oluÅŸturmuyoruz, None dÃ¶nmeli
        if os.path.exists(out):
            os.remove(out)

# --- Ä°Ã‡ERÄ°K ÃœRETÄ°CÄ° (Script + Metadata) ---
def get_content(topic):
    url = f"https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key={GEMINI_API_KEY}"
    
    # Prompt'u JSON formatÄ±nda yanÄ±t isteyecek ÅŸekilde gÃ¼ncelledik
    prompt = (
        f"You are a professional YouTube Shorts creator. Create a viral scary story about '{topic}'. "
        "Output ONLY a valid JSON object with the following keys:\n"
        "- 'script': The scary story text (110-130 words, simple English, short sentences).\n"
        "- 'title': A clickbait title for the video.\n"
        "- 'description': A short engaging description for YouTube.\n"
        "- 'hashtags': A string of 5-10 popular hashtags.\n"
        "Do not write anything else, just the JSON."
    )
    
    payload = {"contents": [{"parts": [{"text": prompt}]}]}
    
    try:
        r = requests.post(url, json=payload, timeout=20)
        if r.status_code == 200:
            data = r.json()
            raw_text = data['candidates'][0]['content']['parts'][0]['text']
            # Markdown formatÄ±nÄ± temizle (bazÄ± modeller ```json ... ``` ekler)
            raw_text = raw_text.replace("```json", "").replace("```", "").strip()
            return json.loads(raw_text)
        else:
            print(f"Gemini API HatasÄ±: {r.status_code} - {r.text}")
    except Exception as e:
        print(f"BaÄŸlantÄ± HatasÄ±: {e}")

    # Fallback (Hata olursa dÃ¶necek varsayÄ±lan deÄŸerler)
    return {
        "script": "I looked at my phone. It showed my face. But I was not holding it. Someone was behind me.",
        "title": "Creepy Glitch ðŸ˜±",
        "description": "Short horror story generated by bot.",
        "hashtags": "#horror #shorts #scary"
    }

# --- VIDEO BUL ---
def get_videos(total_duration):
    headers = {"Authorization": PEXELS_API_KEY}
    queries = ["dark hallway", "creepy room", "abandoned house", "night corridor", "horror atmosphere", "shadows"]
    random.shuffle(queries)

    paths = []
    current = 0
    i = 0

    for q in queries:
        if current >= total_duration:
            break

        url = f"https://api.pexels.com/videos/search?query={q}&per_page=5&orientation=portrait"
        try:
            r = requests.get(url, headers=headers, timeout=15)
            data = r.json().get("videos", [])
        except:
            continue

        for v in data:
            if current >= total_duration:
                break
            
            # En uygun video linkini bul
            video_files = v.get("video_files", [])
            if not video_files: continue
            
            # HD kaliteye yakÄ±n olanÄ± seÃ§meye Ã§alÄ±ÅŸ
            link = max(video_files, key=lambda x: x["height"])["link"]
            path = f"clip_{i}.mp4"
            i += 1

            try:
                with open(path, "wb") as f:
                    f.write(requests.get(link, timeout=20).content)
                
                clip = VideoFileClip(path)
                # Bozuk veya 0 saniyelik videolarÄ± atla
                if clip.duration > 0.5:
                    current += clip.duration
                    paths.append(path)
                clip.close()
            except Exception as e:
                print(f"Video indirme hatasÄ±: {e}")
                continue

    return paths

# --- ALTYAZI ---
def make_subtitles(text, duration):
    font_path = get_font()
    try:
        font = ImageFont.truetype(font_path, 70)
    except:
        font = ImageFont.load_default()

    words = text.split()
    chunks = []
    temp = []
    # Kelimeleri 2-3'lÃ¼ gruplara bÃ¶l
    for w in words:
        temp.append(w)
        if len(temp) >= 2:
            chunks.append(" ".join(temp))
            temp = []
    if temp:
        chunks.append(" ".join(temp))

    if not chunks: return None

    per = duration / len(chunks)
    clips = []

    for ch in chunks:
        img = Image.new("RGBA", (W, H), (0, 0, 0, 0))
        draw = ImageDraw.Draw(img)

        # Metni sar (wrap)
        wrapped = "\n".join(textwrap.wrap(ch.upper(), 15))
        
        # Text boyutunu hesapla
        bbox = draw.textbbox((0, 0), wrapped, font=font)
        tw = bbox[2] - bbox[0]
        th = bbox[3] - bbox[1]

        x = (W - tw) // 2
        y = int(H * 0.75) # Alt kÄ±sma yakÄ±n

        # Siyah arka plan
        draw.rectangle([x-20, y-20, x+tw+20, y+th+20], fill=(0,0,0,160))
        # Beyaz yazÄ±, kalÄ±nlÄ±k efekti iÃ§in hafif kaydÄ±rma yapÄ±labilir ama basit tutuyoruz
        draw.text((x, y), wrapped, font=font, fill="white", align="center")

        clips.append(ImageClip(np.array(img)).set_duration(per))

    return concatenate_videoclips(clips, method="compose")

# --- CLIP DÃœZELT ---
def prepare_clip(path):
    try:
        c = VideoFileClip(path)
        # Sesi kaldÄ±r (Pexels videolarÄ± bazen sesli olabiliyor)
        c = c.without_audio()
        
        # Dikey formata zorla (9:16)
        if c.w / c.h > W / H:
            c = c.resize(height=H)
            c = c.crop(x_center=c.w/2, width=W, height=H)
        else:
            c = c.resize(width=W)
            c = c.crop(y_center=c.h/2, width=W, height=H)
            
        return c
    except:
        return None

# --- MONTAJ ---
def build_video(content_data):
    script = content_data["script"]
    
    # 1. Ses OluÅŸtur
    asyncio.run(generate_tts(script, "voice.mp3"))
    if not os.path.exists("voice.mp3"):
        return None
        
    audio = AudioFileClip("voice.mp3")
    
    # 2. VideolarÄ± Ä°ndir
    paths = get_videos(audio.duration)
    if not paths:
        audio.close()
        return None

    # 3. VideolarÄ± Ä°ÅŸle
    clips = []
    for p in paths:
        c = prepare_clip(p)
        if c:
            clips.append(c)

    if not clips:
        audio.close()
        return None

    # 4. VideolarÄ± BirleÅŸtir
    main = concatenate_videoclips(clips, method="compose")

    # Ses sÃ¼resine eÅŸitle
    if main.duration < audio.duration:
        # EÄŸer video kÄ±sa geldiyse dÃ¶ngÃ¼ye al
        main = main.loop(duration=audio.duration)
    else:
        main = main.subclip(0, audio.duration)

    main = main.set_audio(audio)

    # 5. AltyazÄ± Ekle
    subs = make_subtitles(script, main.duration)
    final = CompositeVideoClip([main, subs], size=(W, H)) if subs else main

    out = "final_video.mp4"
    final.write_videofile(
        out,
        codec="libx264",
        audio_codec="aac",
        fps=FPS,
        threads=2,
        preset="ultrafast" # HÄ±z iÃ§in
    )

    # Temizlik
    for c in clips: c.close()
    audio.close()
    main.close()
    final.close()
    
    # Ä°ndirilen klipleri sil
    for p in paths:
        if os.path.exists(p):
            os.remove(p)

    return out

# --- TELEGRAM ---
@bot.message_handler(commands=["video"])
def handle_video(message):
    args = message.text.split(maxsplit=1)
    if len(args) < 2:
        bot.reply_to(message, "Bir konu yaz: /video horror story")
        return

    topic = args[1]
    bot.reply_to(message, "ðŸŽ¬ Video senaryosu ve kurgusu hazÄ±rlanÄ±yor, bu 1-2 dakika sÃ¼rebilir...")

    # Ä°Ã§eriÄŸi Ã§ek
    content = get_content(topic)
    
    # EÄŸer API hatasÄ± varsa ve script kÄ±sa ise loglarda gÃ¶rÃ¼rÃ¼z
    if len(content["script"].split()) < 20:
        bot.send_message(message.chat.id, "âš ï¸ UyarÄ±: Hikaye Ã§ok kÄ±sa oluÅŸturuldu, API anahtarlarÄ±nÄ± kontrol et.")

    path = build_video(content)

    if path and os.path.exists(path):
        # Caption hazÄ±rlama
        caption_text = (
            f"ðŸŽ¬ **{content['title']}**\n\n"
            f"{content['description']}\n\n"
            f"{content['hashtags']}"
        )
        
        with open(path, "rb") as v:
            bot.send_video(
                message.chat.id, 
                v, 
                caption=caption_text, 
                parse_mode="Markdown"
            )
    else:
        bot.reply_to(message, "âŒ Video oluÅŸturulurken bir hata oluÅŸtu.")

print("Bot Ã§alÄ±ÅŸÄ±yor...")
bot.polling(non_stop=True)

